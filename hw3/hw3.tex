%%%%%%%%%%%%%%%%%%%%% PACKAGE IMPORTS %%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt]{article}
\usepackage{amsmath, amsfonts, amsthm, amssymb}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{fullpage}       
\usepackage{changepage}
\usepackage{hyperref}
\usepackage{blindtext}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
\urlstyle{same}

\newenvironment{level}%
{\addtolength{\itemindent}{2em}}%
{\addtolength{\itemindent}{-2em}}

\usepackage{amsmath,amsthm,amssymb}


\usepackage[x11names, rgb]{xcolor}
\usepackage{graphicx}
\usepackage[nooldvoltagedirection]{circuitikz}
\usetikzlibrary{decorations,arrows,shapes}

\usepackage{datetime}
\usepackage{etoolbox}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{array}
\usepackage{varwidth}
\usepackage{tcolorbox}
\usepackage{amsmath}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage[linguistics]{forest}
\usepackage{listings}
\usepackage{xcolor}
\renewcommand{\rmdefault}{cmss}


\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{mystyle}{
    language=JavaScript,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}

\providetoggle{questionnumbers}
\settoggle{questionnumbers}{true}
\newcommand{\noquestionnumbers}{
    \settoggle{questionnumbers}{false}
}

\newcounter{questionCounter}
\newenvironment{question}[2][\arabic{questionCounter}]{%
    \ifnum\value{questionCounter}=0 \else {\newpage}\fi%
    \setcounter{partCounter}{0}%
    \vspace{.25in} \hrule \vspace{0.5em}%
    \noindent{\bf \iftoggle{questionnumbers}{Question #1: }{}#2}%
    \addtocounter{questionCounter}{1}%
    \vspace{0.8em} \hrule \vspace{.10in}%
}

\newcounter{partCounter}[questionCounter]
\renewenvironment{part}[1][\alph{partCounter}]{%
    \addtocounter{partCounter}{1}%
    \vspace{.10in}%
    \begin{indented}%
       {\bf (#1)} %
}{\end{indented}}

\def\indented#1{\list{}{}\item[]}
\let\indented=\endlist
\def\show#1{\ifdefempty{#1}{}{#1\\}}
\def\IMP{\rightarrow}
\def\AND{\wedge}
\def\OR{\vee}
\def\BI{\leftrightarrow}
\def\DIFF{\setminus}
\def\SUB{\subseteq}


\newcolumntype{C}{>{\centering\arraybackslash}m{1.5cm}}
\renewcommand\qedsymbol{$\blacksquare$}
\newtcolorbox{answer}
{
  colback   = green!5!white,    % Background colorucyitc,
  colframe  = green!75!black,   % Outline color
  box align = center,           % Align box on text line
  varwidth upper,               % Enables multi line input
  hbox                          % Bounds box to text width
}

\newcommand{\myhwname}{Homework 3}
\newcommand{\myname}{Sebastian Liu}
\newcommand{\myemail}{ll57@cs.washington.edu}
\newcommand{\mysection}{AB}
\newcommand{\dollararrow}{\stackrel{\$}{\leftarrow}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%% Document Options %%%%%%%%%%%%%%%%%%%%%%
\noquestionnumbers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%% WORK BELOW %%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{center}
    \textbf{Homework 3} \bigskip
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%% Task 1 %%%%%%%%%%%%%%%%%%%%%%%%M
\begin{question}{Task 1 - Key Recovery (5 + 5 points)}
    \begin{part}
       \begin{answer}
       
        \end{answer}
    \end{part}

    \begin{part}
        \begin{answer}

        \end{answer}
     \end{part}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 2 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 2 - When IVs Collide (8 points)}
    \begin{part}
       \begin{answer}
            By the encryption procedure of CTR mode, we know:
            $$C_0[i] \leftarrow M_0[i] \oplus \text{E}(K, \text{IV}_0 + i)$$
            $$C_1[i] \leftarrow M_1[i] \oplus \text{E}(K, \text{IV}_1 + i)$$
            
            Since $C_0[0] = C_1[0]$ (i.e. $\text{IV}_0 = \text{IV}_1$), we have:
            $$C_0[i] \oplus C_1[i] = M_0[i] \oplus \text{E}(K, \text{IV}_0 + i) \oplus M_1[i] \oplus \text{E}(K, \text{IV}_1 + i) = M_0[i]  \oplus M_1[i] $$
            If we apply $ C_0[i] \oplus C_1[i] =  M_0[i]  \oplus M_1[i]$ to each block, we have:
            $$M_0 \oplus M_1 =  C_0 \oplus C_1$$

            
            Therefore, if the initialization vector for CTR mode collides, we can learn the value of the XOR of two plaintexts by XORing 
            their ciphertexts.
       \end{answer}
    \end{part}

    \begin{part}
        \begin{answer}
            By the encryption procedure of CBC mode, we know:
            $$C_0[i] \leftarrow \text{E}(K, M_0[i] \oplus C_0[i - 1])$$
            $$C_1[i] \leftarrow \text{E}(K, M_1[i] \oplus C_1[i - 1])$$
            
            Since $C_0[0] = C_1[0]$ (i.e. $\text{IV}_0 = \text{IV}_1$), we have:
            $$C_0[1] \leftarrow \text{E}(K, M_0[1] \oplus C_0[0])$$
            $$C_1[1] \leftarrow \text{E}(K, M_1[1] \oplus C_1[0])$$
           
            As we can see, if $M_0 = M_0[1]M_0[2]...M_0[q] = M_1[1]M_1[2]M_1[q] = M_1$ we have:
            $$C_0[1] = E(K, M_0[1] \oplus C_0[0]) = E(K, M_1[1] \oplus C_1[0]) = C_1[1]$$
            $$C_0[2] = E(K, M_0[2] \oplus C_0[1]) = E(K, M_1[2] \oplus C_1[1]) = C_1[2]$$
            $$...$$
            $$C_0[q] = E(K, M_0[q] \oplus C_0[q-1]) = E(K, M_1[q] \oplus C_1[q-1]) = C_1[q]$$

            
            Therefore, when the initialization vector for CBC mode collides, we know that if two ciphertexts are the same, the two corresponding plaintexts are also the same. 
        \end{answer}
    \end{part}
   

\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 3 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 3 - IND-CPA Security (10 points)} 
    \begin{part}
       \begin{answer}
            Since we use PKCS\#7 to pad plaintext $M$ into 16-byte blocks, for plaintexts that are less than 16 bytes in length, we will only have one block of ciphertexts:
            $$C_{M < 16 \text{ bytes}} \leftarrow R || \text{AES}(K, M[1] +1 + R)$$
            Since every time we encrypt a new plaintext, we generate a random 16-byte mask $R$, the probability of having different masks for two different plaintexts is 
            very high (i.e. $1 - 2^{-128}$).\\  
            So for two plaintexts $M_0$ and $M_1$, the probability of $M_0[1] + 1 + R_0 = M_1[1] + 1 + R_1$ is very low (less than $2^{-128}$).\\
            Because we assume AES is a good PRF, given $M_0[1] + 1 + R_0 \ne M_1[1] + 1 + R_1$, AES should return two blockciphers $C_0$ and $C_1$ which is as good as directly sampling two uniformly random 16-byte strings (effectively a one-time pad).\\
            Therefore, we can't tell which ciphertext is the encryption of which plaintext, so the scheme is IND-CPA secure.
       \end{answer}
    \end{part}

    \begin{part}
        \begin{answer}
           Assume we pick two 32-byte long plaintexts $M_0$ and $M_1$ where after padding: 
           $$M_0[1] + 1 = M_0[2] + 2$$
           $$M_1[1] + 1 \ne M_1[2] + 2$$
           By the encryption scheme, we will have the following ciphertexts:
           $$C_0 \leftarrow R || \text{AES}(K,M_0[1] + 1 + R_0) ||  \text{AES}(K,M_0[2] + 2 + R_0)$$
           $$C_1 \leftarrow R || \text{AES}(K,M_1[1] + 1 + R_1) ||  \text{AES}(K,M_1[2] + 2 + R_1)$$
           Since AES is deterministic, and we picked $M_0[1] + 1 = M_0[2] + 2$ and $M_1[1] + 1 \ne M_1[2] + 2$, we know:
           $$\text{AES}(K,M_0[1] + 1 + R_0) =  \text{AES}(K,M_0[2] + 2 + R_0)$$
           $$\text{AES}(K,M_1[1] + 1 + R_1) \ne  \text{AES}(K,M_1[2] + 2 + R_1)$$
           Base on this, we can construct a distinguisher which can distinguish $C_0$ and $C_1$ with probability 1 by checking if the second and third block of the ciphertext are the same.\\
           Therefore, the scheme is not IND-CPA secure for plaintexts that are longer than 16 bytes. 
        \end{answer}
     \end{part}


\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 4 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 4 - Padding-Oracle Attack (22 points)} 
    \begin{part}
       \begin{answer}
            \textbf{Case 1 (if the last byte of the last plaintext block is validly padded):} \\
                For all possible guesses $X$: 
                \begin{enumerate}
                   \item Change the last byte $Y$ of the second-last ciphertext block to $X \oplus Y \oplus 01$ 
                    \item Submit resulting ciphertext to padding oracle. If padding oracle says ciphertext has valid padding (we should only have one $X$ that satisfy this condition), take $X$ as the value of the last byte.
                \end{enumerate}

            \textbf{Case 2 (if the last byte of the last plaintext block is not validly padded):}\\
                For all possible guesses  $X$ : 
                \begin{enumerate}
                    \item Change the last byte  $Y$  of the second-last ciphertext block to  $X \oplus Y \oplus 01$.
                    \item Submit the resulting ciphertext to the padding oracle. If the padding oracle says the ciphertext has valid padding, make a note of this value of  $X$ .
    
                   After searching through all $X \in \{0,1\}^8$, we'll likely have identified two values  $X_1$  and  $X_2$  that satisfy the condition. \\\\
                     \textit{[To show this, we can use the example in class: \\
                    If the original plaintext is not padded correctly, let's say the last byte was $0B$, then after searching through all possible $X$'s, we will
                    get two values that will achieve the two valid paddings:
                    (i.)  $0A$ 
                    (ii) $01$ \\\\}
                    To find correct value between  $X_1$  and  $X_2$, we do the\\ following:
    
                    \item Change the second-last byte $Z$ of the second-last ciphertext block to a different random value (or we can simply flip the last bit of $Z$ ).
                    \item Change the last byte $Y$ of the second-last ciphertext block to  $X_1 \oplus Y \oplus 01$.
                    \item Submit this resulting ciphertext to the padding oracle.
                    \item If the padding oracle says the ciphertext has valid padding, then $X_2$ is the correct value for the last 
                        byte (because if $X_1$ was the correct value, changing the second-last byte $Z$ would have invalidated the padding). Otherwise, $X_1$ is the 
                        correct value for the last byte (because it suggests the correct padding is just $01$, changing the second-last byte didn't break anything). 
                \end{enumerate}
       \end{answer}
    \end{part}
\newpage
    \begin{part}
        \begin{answer}
            \textbf{Strategy:}
            \begin{enumerate}
                \item Split the ciphertext $ C $ into blocks: $  C_0, C_1, ... C_n $ (target is to recover $P_1, P_2, ..., P_n$).
                \item For each block $  C_i  $ starting from $  C_n  $ and moving to $  C_1  $:
                     recover each byte in the block, starting from the last byte and moving to the first.
                \item For each byte position in block $  C_i  $:\\
                    Assume we have $C_i = [c_1, c_2, ... c_{16}]$ and we want to recover $P_i = [p_1, p_2, ... p_{16}]$.
                    \begin{enumerate}
                        \item Using the strategy described in part a) to recover the last byte of the last plaintext block ($p_{16}$).
                        \item Recovering the second-last byte ($p_{15}$):\\
                         The target is to change $C_i$ to $C_i'$ such that when decrypted, its last two bytes become $02 02$.
                        \begin{enumerate}
                            \item Change the already recovered last byte: $c_{16}' = c_{16} \oplus p_{16} \oplus 02$ (so the last byte will be decrypted to $02$). 
                            \item For all possible guesses $X$:
                            \begin{enumerate}
                                \item Change the second-last byte: $c_{15}' = X \oplus c_{15} \oplus 02$.
                                \item Submit resulting ciphertext $C_i' = [c_1, c_2, ..., c_{15}', c_{16}']$ to padding oracle.
                                \item If padding oracle says ciphertext has valid padding, then $p_{15} = X $.
                            \end{enumerate}
                        \end{enumerate}
                        \item Continue this process for each preceding byte:
                            \begin{enumerate}
                                \item For the 3rd last byte, target decryption of the last three bytes becomes $03 03 03$.
                                \item For the 4th last byte, target decryption of the last four bytes becomes $04 04 04 04$.
                                \item ... and so on.
                            \end{enumerate}
                        \item Once all bytes in $P_i$ are recovered, we move to the next block $P_{i - 1}$and use $C_{i-1}$ to recover it. 
                    \end{enumerate}
                \item Repeat step 3 for all blocks.
                \item Once recovered the last block ($P_1$), we remove the PKCS\#7 padding from the final plaintext block to get the original message.
            \end{enumerate}

        \textbf{Number of padding validity checks:} \\
        In the worst case scenario, for each byte position, we have to check $2^8 = 256$ possibilities.
        Given a block size of $  b  $ bytes and $  n  $ blocks we need $ b \times 256 \times n $ checks in the worst case.
   
        \end{answer}
     \end{part}

\end{question}
\end{document}