%%%%%%%%%%%%%%%%%%%%% PACKAGE IMPORTS %%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt]{article}
\usepackage{amsmath, amsfonts, amsthm, amssymb}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{fullpage}       
\usepackage{changepage}
\usepackage{hyperref}
\usepackage{blindtext}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
\urlstyle{same}

\newenvironment{level}%
{\addtolength{\itemindent}{2em}}%
{\addtolength{\itemindent}{-2em}}

\usepackage{amsmath,amsthm,amssymb}


\usepackage[x11names, rgb]{xcolor}
\usepackage{graphicx}
\usepackage[nooldvoltagedirection]{circuitikz}
\usetikzlibrary{decorations,arrows,shapes}

\usepackage{datetime}
\usepackage{etoolbox}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{array}
\usepackage{varwidth}
\usepackage{tcolorbox}
\usepackage{amsmath}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage[linguistics]{forest}
\usepackage{listings}
\usepackage{xcolor}
\renewcommand{\rmdefault}{cmss}


\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{green},
    morecomment=[l][\color{magenta}]{\#},
    backgroundcolor=\color{backcolour},   
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}

\providetoggle{questionnumbers}
\settoggle{questionnumbers}{true}
\newcommand{\noquestionnumbers}{
    \settoggle{questionnumbers}{false}
}

\newcounter{questionCounter}
\newenvironment{question}[2][\arabic{questionCounter}]{%
    \ifnum\value{questionCounter}=0 \else {\newpage}\fi%
    \setcounter{partCounter}{0}%
    \vspace{.25in} \hrule \vspace{0.5em}%
    \noindent{\bf \iftoggle{questionnumbers}{Question #1: }{}#2}%
    \addtocounter{questionCounter}{1}%
    \vspace{0.8em} \hrule \vspace{.10in}%
}

\newcounter{partCounter}[questionCounter]
\renewenvironment{part}[1][\alph{partCounter}]{%
    \addtocounter{partCounter}{1}%
    \vspace{.10in}%
    \begin{indented}%
       {\bf (#1)} %
}{\end{indented}}

\def\indented#1{\list{}{}\item[]}
\let\indented=\endlist
\def\show#1{\ifdefempty{#1}{}{#1\\}}
\def\IMP{\rightarrow}
\def\AND{\wedge}
\def\OR{\vee}
\def\BI{\leftrightarrow}
\def\DIFF{\setminus}
\def\SUB{\subseteq}


\newcolumntype{C}{>{\centering\arraybackslash}m{1.5cm}}
\renewcommand\qedsymbol{$\blacksquare$}
\newtcolorbox{answer}
{
  colback   = green!5!white,    % Background colorucyitc,
  colframe  = green!75!black,   % Outline color
  box align = center,           % Align box on text line
  varwidth upper,               % Enables multi line input
  hbox                          % Bounds box to text width
}

\newcommand{\myhwname}{Homework 6}
\newcommand{\myname}{Sebastian Liu}
\newcommand{\myemail}{ll57@cs.washington.edu}
\newcommand{\mysection}{AB}
\newcommand{\dollararrow}{\stackrel{\$}{\leftarrow}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%% Document Options %%%%%%%%%%%%%%%%%%%%%%
\noquestionnumbers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%% WORK BELOW %%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{center}
    \textbf{Homework 6} \bigskip
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%% Task 1 %%%%%%%%%%%%%%%%%%%%%%%%M
\begin{question}{Task 1 - RSA Modulus Generation (10 points)}
    \begin{part}
       \begin{answer}
            Given that $N = PQ$, $P = R - i$ and $Q = R + j$, where $R$ is a k-bit integer and (since primes are dense) $i, j$ are relatively small integers, we have two scenarios:\\
            1. If $R$ is not a prime, then $P$ and $Q$ are neighboring primes in the set of $k$-bit numbers.\\
            2. If $R$ is a prime, then $P$ and $Q$ are immediate prime neighbors of $R$.\\\\
            In both scenarios, since $P$ and $Q$ are close to each other, the value of $N$ can be efficiently factorized.
            One approach can be to search for primes near the square root of $N$, which would be approximately $\sqrt{N} \approx R$. 
            This search is feasible in polynomial time relative to $k$. Once an attacker can factor \( N \) and find \( P \) and \( Q \), 
            they can efficiently compute the private key by using the public key $PK(N, e)$ and looking for a decryption exponent
            $d$ in $\mathbb{Z}_{(P-1)(Q-1)}^*$ , such that $e d = 1 \text{ (mod } (P-1)(Q -1))$.\\\\
            The proximity of $P$ and $Q$ ( $|P - Q|$  is small) significantly reduces the complexity of the factorization problem. 
            Since RSA security relies on the difficulty of factoring $N$, the method mentioned above of generating
            $P$ and $Q$ compromises the security of RSA modulus.
           
        \end{answer}
    \end{part}
\newpage
    \begin{part}
        \begin{answer}
             $P = 35123014591230139123011933120312223198716238123918231119382061$ \\
             $Q = 35123014591230139123011933120312223198716238123918231119382447$ 
         \end{answer}
         \begin{lstlisting}
    from sympy import isprime
    from timeit import default_timer as timer
    import math

    # The RSA modulus N
    N = 12336261539757652568320691057196254494530050076556470009232333
        67120767290238588667397052161653352801437540471197470570083267

    def factor(N):
        # Approximate square root of N
        approx_sqrt_N = int(math.isqrt(N))

        # Search for prime factors near the square root of N
        for i in range(approx_sqrt_N, 1, -1):
            print("Trying i = ", i)
            if N % i == 0 and isprime(i):
                # double check
                if isprime(N // i) and i * (N // i) == N:
                    return i, N // i

        print("Error: no factors found")
        return None, None

    # Find P and Q
    timer_start = timer()
    P, Q = factor(N)
    timer_end = timer()
    print("P = ", P, "Q = ", Q, "Time = ", timer_end - timer_start)
        \end{lstlisting}
     \end{part}

\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 2 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 2 - ElGamal and DDH (15 points)}
    \begin{part}
        \begin{answer}
            \textbf{Decryption Algorithm:}
            \begin{center}
                \begin{tabular}{|l|}
                    \hline
                    \underline{\textbf{procedure} Dec($\text{SK}, C = (C_1, C_2)$) :} \\
                    \textbf{if} $C_1^{\text{SK}} = C_2$ \textbf{then} \\
                    \hspace*{22pt} \textbf{return} $0$ \\
                    \textbf{else} \\
                    \hspace*{22pt} \textbf{return} $1$\\
                    \hline
                \end{tabular}
            \end{center}
            \textbf{Correctness when $b = 0$:} \\
            - During encryption, we have \( C_1 = g^y \) and \( C_2 = PK^y = (g^x)^y = g^{xy} \).\\
            - During decryption, we have \( C_1^{\text{SK}} = (g^y)^x = g^{yx} = g^{xy} = C_2 \).\\
            - Thus, when $b = 0$, the decryption algorithm will always correctly output $0$.\\\\
            \textbf{Correctness when $b = 1$:} \\
            - During encryption, we have \( C_1 = g^y \) and \( C_2 = g^z \), where \( y \overset{\text{\$}}{\leftarrow} \mathbb{Z}_p  \) 
            and \( z \overset{\text{\$}}{\leftarrow} \mathbb{Z}_p \).\\
            - During decryption, we have \( C_1^{\text{SK}} = (g^y)^x = g^{yx} \). Since \( y \) and \( z \) are independently and uniformly 
            chosen from \( \mathbb{Z}_p \)and group $\mathbb{Z}_p$ has prime order $p$, the probability that \( g^{yx} = g^z \) (i.e., \( C_1^{\text{SK}} = C_2 \)) 
            is $$\text{Pr}[ yx \equiv z  \text{ (mod } p )] = \frac{1}{p} $$
            - Thus, the probability of the decryption algorithm incorrectly return $0$ is \( \frac{1}{p} \), which is very small when the prime order 
            $p$ is sufficiently large.\\\\
            Therefore, we have shown that the correctness requirement of the scheme may sometimes not hold, but only with very small probability.
         \end{answer}
     \end{part}
\newpage
     \begin{part}
        \begin{answer}
            The following oracle satisfies this, which is given access to $\mathsf{DDH}_b[\mathbb{G}, g]$ for $b \in \{0, 1\}$.
            \begin{center}
            \begin{tabular}{|l|}
                \hline
                    \underline{\textbf{oracle} $\text{O}^{\text{DDH}_b[\mathbb{G},g]}$:} \\\\
                    \underline{private \textbf{procedure} Init($X,Y,Z$):} \;\;\;\;\;\; \textcolor{blue}{// $(X,Y,Z) \leftarrow \text{DDH}_b[\mathbb{G},g]$}\\
                        queried \(\leftarrow 0\)\\
                        \textbf{return} $X$\\\\
                    \underline{public \textbf{procedure} Encrypt():} \\
                        \textbf{if} queried $= 1$ \textbf{return} $\bot$\\
                        $C \leftarrow (Y,Z)$;
                        queried $\leftarrow 1$\\
                        \textbf{return} $C$\\
                    \hline
            \end{tabular}
        \end{center}
        We can see that:\\
        1) \( O^{\mathsf{DDH}_0[\mathbb{G},g]} \equiv \mathsf{1-LR}_0[\Pi] \):\\
        The \( \text{Init} \) procedure in oracle \( O \) takes input \( (X,Y,Z) = (g^x, g^y, g^{xy}) \)
        from \( \mathsf{DDH}_0[\mathbb{G},g] \).
        The \( \text{Init} \) procedure then returns \( X \) which is analogous to the public key \( PK = g^x \) 
        in the \( \mathsf{1-LR}_0[\Pi] \) oracle.\\
        The \( \text{Encrypt} \) procedure in \( O \) outputs \( (Y, Z) \) which corresponds to 
        \( (g^y, g^{xy}) \). In \( \mathsf{1-LR}_0[\Pi] \), when \( b = 0 \), the encryption algorithm outputs 
        \( (C_1, C_2) = (g^y, PK^y) \). Here, \( PK^y = (g^x)^y = g^{xy} \), which matches the output 
        of \( O \) under \( \mathsf{DDH}_0[\mathbb{G},g] \). \\
        Therefore, \( O^{\mathsf{DDH}_0[\mathbb{G},g]} \) 
        is equivalent to \( \mathsf{1-LR}_0[\Pi] \).\\
        
        2) \( O^{\mathsf{DDH}_1[\mathbb{G},g]} \equiv \mathsf{1-LR}_1[\Pi] \):\\
        The \( \text{Init} \) procedure takes \( (X,Y,Z) = (g^x, g^y, g^z) \) 
        from \( \mathsf{DDH}_1[\mathbb{G},g] \) and returns \( X \), which serves as the public key \( PK \).\\
        The \( \text{Encrypt}() \) procedure 
        in \( O \) under \( \mathsf{DDH}_1[\mathbb{G},g] \) outputs \( (Y, Z) \), which corresponds to \( (g^y, g^z) \). 
        In \( \mathsf{1-LR}_1[\Pi] \), when \( b = 1 \), the encryption algorithm chooses random \( y, z \) 
        in \( \mathbb{Z}_p \) and outputs \( (C_1, C_2) = (g^y, g^z) \)  which matches the output 
        of \( O \) under \( \mathsf{DDH}_1[\mathbb{G},g] \). \\
        Therefore, \( O^{\mathsf{DDH}_1[\mathbb{G},g]} \) 
        is equivalent to \( \mathsf{1-LR}_1[\Pi] \).\\
         \end{answer}
     \end{part}
\newpage
     \begin{part}
        \begin{answer}
             Using the oracle $\text{O}$ from part (b), let $D$ by a polynomial-time distinguisher, then we have:
             \begin{align*}
                \text{Adv}^{\text{1-ind-cpa}}_{\Pi}(D) &= |\text{Pr}[D^{\text{1-LR}_0[\Pi]} \Rightarrow 1] - \text{Pr}[D^{\text{1-LR}_1[\Pi]} \Rightarrow 1]|\\
                &= |\text{Pr}[D^{O^{\text{DDH}_0[\mathbb{G},g]}} \Rightarrow 1] - \text{Pr}[D^{O^{\text{DDH}_1[\mathbb{G},g]}} \Rightarrow 1]|\\
                &= \text{Adv}^{\text{ddh}}_{\mathbb{G},g}(D') \tag*{\textcolor{blue}{// where $D' = D^{O^{\text{DDH}_b[\mathbb{G},g]}}$}}\\
             \end{align*}
                Further, if $D$ is polynomial time, because O’s procedures all run in polynomial time, we also have that $D'$ is polynomial time.\\
                Then, because we assume DDH assumption holds for $\mathbb{G}$ with respect to $g$, $\text{Adv}^{\text{ddh}}_{\mathbb{G},g}(D)$ is negligible, which 
                means that $\text{Adv}^{\text{1-ind-cpa}}_{\Pi}(D')$ is also negligible (since the input of $D'$ first passed through the Init procedure of O, which takes 
                the output oracle $\text{DDH}_b[\mathbb{G}, g]$ as input).\\
                Therefore, we have shown that if DDH assumption holds for $\mathbb{G}$ with respect to $g$, then $\Pi$ is one-time IND-CPA secure.
         \end{answer}
     \end{part}

\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 3 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 3 - Chosen-Ciphertext Security (10 points)} 
    \begin{part}
        \begin{answer}
            To produce a modified ciphertext \( C' \) that encrypts \( M \star \delta \) (for a known \( \delta \in \mathbb{G} \)), we first know 
            that the encryption of \( M \star \delta \) should be \( (g^r, (M \star \delta) \star \text{PK}^r) \) by the ElGamal scheme.\\
            The operation \( \star \) in cyclic group \( \mathbb{G} \) is known to be associative and commutative, the expression 
            \( (M \star \delta) \star \text{PK}^r \) can be rewritten as \( (M \star \text{PK}^r) \star \delta \) \\
            Thus, the modified ciphertext \( C' \) can be computed as:
            \[ C' = (g^r, (M \star \text{PK}^r) \star \delta) \]
            Since \( C = (g^r, M \star \text{PK}^r) \) is known, assuming the group operation \( \star \) is efficiently computable, 
            we can efficiently calculate the second component of \( C' \) as \( (M \star \text{PK}^r) \star \delta \).\\
            Therefore, we have shown that we can efficiently produce the encryption of \( M \star \delta \) given the encryption of 
            \( M \) and a known \( \delta \).
        \end{answer}
     \end{part}

     \begin{part}
        \begin{answer}
            We know that $M_1 \ne M_2$. Let's assume for contradiction that $M_1 \star \delta = M_2 \star \delta$.\\
            Since $\delta \in \mathbb{G}$, by the inverse property of groups, we know there exists $\delta^{-1} \in \mathbb{G}$ 
            such that $\delta \star \delta^{-1} = 1$.\\
            Then, we can multiply both sides of the equation $M_1 \star \delta = M_2 \star \delta$ by $\delta^{-1}$ to get:
            $$M_1 \star \delta \star \delta^{-1} = M_2 \star \delta \star \delta^{-1}$$
            which, by the identity property of group, simplifies to:
            $$M_1 = M_2 $$
            This contradicts the fact that $M_1 \ne M_2$. \\
            Therefore, by contradiction, we have shown that $M_1 \star \delta \ne M_2 \star \delta$ (i.e. $M_1 \star \delta$ 
            and $M_2 \star \delta$ are distinct).
        \end{answer}
     \end{part}
\newpage
     \begin{part}
        \begin{answer}
            An attack on the given ElGamal scheme is demonstrated by the following distinguisher \( D \), which accesses the oracle \( \text{LRD}_b[\Pi] \), where \( \Pi \) is the ElGamal scheme.
             \begin{center}
                \begin{tabular}{|l|}
                    \hline
                        \underline{\textbf{distinguisher} $D^{\text{O}}(\text{PK, } g)$:} \\
                            $M_0 \leftarrow g^0$ \\
                            $M_1 \leftarrow g^1$ \\
                            $\delta \leftarrow g^2$ \\
    
                            $(C_1, C_2) \leftarrow $ O.Encrypt$(M_0, M_1)$\\
                            $C' \leftarrow (C_1, C_2 \star \delta)$\\
                            $M' \leftarrow \text{O.Decrypt(C')}$\\
                            \textbf{if $M' = M_0 \star \delta$ then} \\
                            \hspace{1em} \textbf{return} 1 \\
                            \textbf{else return }0 \\
                        \hline
                        \end{tabular}
            \end{center}
            By the above:\\
             When \( O = \text{LRD}_0[\Pi] \), the oracle encrypts \( M_0 = g^0 \). As shown in part(a), \( C' \) will be the 
             encryption of \( M_0 \star \delta \), and the decryption oracle will return \( M_0 \star \delta \), which is not equal to $M_1 \star \delta$ (as shown in part(b)). 
             Thus, \( D \) will always return 1.\\\\
             When \( O = \text{LRD}_1[\Pi] \), the oracle encrypts \( M_1 = g^1 \). As shown in part(a), 
             \( C' \) will be an encryption of \( M_1 \star \delta \), and the decryption oracle will return \( M_1 \star \delta \), 
             which is not equal to $M_0 \star \delta$ (as shown in part(b)). Thus, \( D \) will always return 0.\\


            So we have, $\text{Adv}^{\text{ind-cca}}_{\Pi}(D) = |\text{Pr}[D^{\mathsf{LRD}_0[\Pi]} \Rightarrow 1] - \text{Pr}[D^{\mathsf{LRD}_1[\Pi]} \Rightarrow 1]| = |1 - 0| = 1$.\\
            Therefore, we have shown that the ElGamal encryption scheme is not IND-CCA secure.
         \end{answer}
     \end{part}

\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 4 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 4 - AES-Based Signatures (15 points)} 
    \begin{part}
        \begin{answer}
            Given only \( VK \), an adversary does not have access to the secret key \( SK \) but only 
            the AES encryptions of the secret key.\\
             To forge a signature on any message \( M^* \), the adversary would need to produce a sequence 
             \( \sigma^* \) such that \( \text{AES}(\sigma^*_i, 0^{128}) \) equals \( C_{i,M^*_i} \) for each bit \( i \) in 
             \( M^* \). The adversary has two options:\\
             1) Reverse the AES function to recover the secret key \( K_{i,M^*_i} \) from \( C_{i,M^*_i} \).\\
             2) Guess the secret key \( K_{i,M^*_i} \) for each bit \( i \) in \( M^* \).\\
             
             
            By our assumption, inverting the AES function to recover the correct \( K_{i,M^*_i} \) from \( C_{i,M^*_i} \), 
            is hard. Since the AES keys were chosen randomly and independently, the adversary gets no 
            advantage in computing one key from another, so the problem remains hard for each bit of the message.\\
            Thus, the first option is infeasible for "efficient" adversaries.\\
             
            Moreover, the adversary cannot simply guess the keys since they are 128-bit strings (the search space is
            \( 2^{128} \)), which means the adversary will guess the correct key with very small probability. So, 
            the second option is also infeasible for any "efficient" adversary.\\

            Therefore, any "efficient" adversary cannot forge a signature \( \sigma^* \) for any message \( M^* \) such that 
            \( \text{Ver}(VK, M^*, \sigma^*) \) outputs 1, which 
            shows that the signature scheme \( \Sigma \) satisfies key-only unforgeability.
         \end{answer}
     \end{part}

     \begin{part}
        \begin{answer}
            If an adversary is given a valid signature \( \sigma \) for a message \( M \), they still face the same difficulty 
            in part (a) for any bit of a new message \( M^* \neq M \). \\

            The reason is that each bit \( M_i \) of \( M \) is signed with a distinct key \( K_{i,M_i} \). For any bit 
            \( M_i^* \) of \( M^* \) that differs from \( M_i \), the adversary needs the corresponding key \( K_{i,M_i^*} \) 
            to produce a valid signature bit \( \sigma_i^* \).\\

            Since they only have \( K_{i,M_i} \) from the known signature 
            \( \sigma \), and due to the hardness assumption of AES, they cannot efficiently derive \( K_{i,M_i^*} \) from any 
            of the known information.\\

            Therefore, even with a valid signature for a chosen message, the adversary cannot generate a new valid signature 
            for any different message because each bit of the signature is protected by an independent key that the adversary 
            cannot efficiently compute.
 
         \end{answer}
     \end{part}
\newpage
     \begin{part}
        \begin{answer}
            To show that the scheme is not UF-CMA secure, consider the following adversary \( A \), which accesses the oracle
            $\mathsf{UF-CMA}[\Sigma]$, where $\Sigma$ is the AES-based signature scheme proposed in the question.
            \begin{center}
                \begin{tabular}{l}
                        \underline{\textbf{adversary} $A^{O}()$:} \\
                            $(\sigma_1,...,\sigma_n) \leftarrow \mathsf{O.Eval}(0^n)$\\
                            $(\sigma'_1,...,\sigma'_n) \leftarrow \mathsf{O.Eval}(1^n)$\\
                            $M^* = (1 || 0^{n-1})$ \;\;\;\;\;\;\;\;\;\;\;\;\; \textcolor{blue}{// only flipping the first bit of $0^n$}\\
                            $\sigma^* \leftarrow (\sigma'_1, \sigma_2,...,\sigma_n)$\;\;\;\;\;\; \textcolor{blue}{// only replacing $\sigma_1$ in $\sigma$ with $\sigma'_1$}\\
                        \textbf{return} $M^*, \sigma^*$
                    \end{tabular}
                \end{center}

            Since \( M^* \) is different from both \( 0^n \) and \( 1^n \), $M^*$ is unknown to the oracle (i.e., $M^* \notin \mathcal{Q}$).\\
            Since the first bit of $M^*$ matches with $1^n$, \( \ \sigma_1^* = \sigma'_1 \) is a valid first signature 
            bit for \( M^* \).\\
            Since all other bits in $M^*$ matches with $0^n$, \( \sigma^*_i = \sigma_i \) ($1 < i \le n$) is a valid signature bit for $M^*$. \\
            Thus, \( \sigma^* \) is a valid signature for \( M^* \).\\

            The finalization procedure in the oracle will return $1$ when the adversary returns \( M^* \) and \( \sigma^* \) 
            because for each bit \( i \), \( \text{AES}(\sigma_i^*, 0^{128}) = C_{i,M_i^*} \)\\
            Therefore, \( \text{Adv}^{\text{uf-cma}}_{\Sigma} (A) = 1 \),
            and \( A \) successfully forges a signature, which shows that the scheme $\Sigma$ is not UF-CMA secure.
         \end{answer}
     \end{part}

\end{question}
\end{document}

