%%%%%%%%%%%%%%%%%%%%% PACKAGE IMPORTS %%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt]{article}
\usepackage{amsmath, amsfonts, amsthm, amssymb}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{fullpage}       
\usepackage{changepage}
\usepackage{hyperref}
\usepackage{blindtext}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
\urlstyle{same}

\newenvironment{level}%
{\addtolength{\itemindent}{2em}}%
{\addtolength{\itemindent}{-2em}}

\usepackage{amsmath,amsthm,amssymb}


\usepackage[x11names, rgb]{xcolor}
\usepackage{graphicx}
\usepackage[nooldvoltagedirection]{circuitikz}
\usetikzlibrary{decorations,arrows,shapes}

\usepackage{datetime}
\usepackage{etoolbox}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{array}
\usepackage{varwidth}
\usepackage{tcolorbox}
\usepackage{amsmath}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage[linguistics]{forest}
\usepackage{listings}
\usepackage{xcolor}
\renewcommand{\rmdefault}{cmss}


\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{mystyle}{
    language=JavaScript,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}

\providetoggle{questionnumbers}
\settoggle{questionnumbers}{true}
\newcommand{\noquestionnumbers}{
    \settoggle{questionnumbers}{false}
}

\newcounter{questionCounter}
\newenvironment{question}[2][\arabic{questionCounter}]{%
    \ifnum\value{questionCounter}=0 \else {\newpage}\fi%
    \setcounter{partCounter}{0}%
    \vspace{.25in} \hrule \vspace{0.5em}%
    \noindent{\bf \iftoggle{questionnumbers}{Question #1: }{}#2}%
    \addtocounter{questionCounter}{1}%
    \vspace{0.8em} \hrule \vspace{.10in}%
}

\newcounter{partCounter}[questionCounter]
\renewenvironment{part}[1][\alph{partCounter}]{%
    \addtocounter{partCounter}{1}%
    \vspace{.10in}%
    \begin{indented}%
       {\bf (#1)} %
}{\end{indented}}

\def\indented#1{\list{}{}\item[]}
\let\indented=\endlist
\def\show#1{\ifdefempty{#1}{}{#1\\}}
\def\IMP{\rightarrow}
\def\AND{\wedge}
\def\OR{\vee}
\def\BI{\leftrightarrow}
\def\DIFF{\setminus}
\def\SUB{\subseteq}


\newcolumntype{C}{>{\centering\arraybackslash}m{1.5cm}}
\renewcommand\qedsymbol{$\blacksquare$}
\newtcolorbox{answer}
{
  colback   = green!5!white,    % Background colorucyitc,
  colframe  = green!75!black,   % Outline color
  box align = center,           % Align box on text line
  varwidth upper,               % Enables multi line input
  hbox                          % Bounds box to text width
}

\newcommand{\myhwname}{Homework 5}
\newcommand{\myname}{Sebastian Liu}
\newcommand{\myemail}{ll57@cs.washington.edu}
\newcommand{\mysection}{AB}
\newcommand{\dollararrow}{\stackrel{\$}{\leftarrow}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%% Document Options %%%%%%%%%%%%%%%%%%%%%%
\noquestionnumbers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%% WORK BELOW %%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{center}
    \textbf{Homework 5} \bigskip
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%% Task 1 %%%%%%%%%%%%%%%%%%%%%%%%M
\begin{question}{Task 1 - Group Generators (8 points)}
    \begin{part}
       \begin{answer}
            Since $a \in \mathbb{Z}_m^*$, by the inverse property of the multiplicative groups, we know  $ \exists \; a^{-1}$ such that $a^{-1} \cdot a = 1$.\\
            Given the equation $ax \equiv b$ (mod $m$), we can multiply both sides by $a^{-1}$ to get: 
            $$ a^{-1} \cdot a \cdot x \equiv a^{-1} \cdot b \text{ (mod }m)$$
            which simplifies to:
            $$ x \equiv a^{-1} \cdot b \text{ (mod }m).$$

            This shows that for any \( b \in \mathbb{Z}_m \), the value \( x = a^{-1} \cdot b \text{ (mod }m) \) is a 
            solution to the modular equation \( ax \equiv b\text{ (mod }m)\).

            Thus, we have shown that there always exists a solution to the modular equation \( ax \equiv b \text{ (mod }m)\) 
            for any \( b \in \mathbb{Z}_m \), given that \( a \in \mathbb{Z}^*_m \) and \( m \geq 2 \).
        \end{answer}
    \end{part}

    \begin{part}
        \begin{answer}
            Since \( a \in \mathbb{Z}_m \setminus \mathbb{Z}^*_m \), we know that \( a \) is not coprime to \( m \) (i.e. \( \gcd(a,m) > 1 \)).\\
            Let \( d = \gcd(a, m)\).
            We choose a \( b \in \mathbb{Z}_m \) that is not divisible by \( d \). \\
            Our goal is to show that for this
            \( b \), the equation \( ax \equiv b \text{ (mod }m)\) has no solution in terms of $x$.\\

            Assume for contradiction that there exists an \( x \in \mathbb{Z}_m \) such that 
            \( ax \equiv b \text{ (mod }m)\), which means that \( m \) divides \( ax - b \). \\
            Since \( d \) divides
            \( a \) and \( m \), it must also divide \( ax \). However, \( b \) is chosen such that it is not divisible
            by \( d \), therefore \( ax - b \) cannot be divisible by \( m \), since \( m \) is divisible by \( d \). \\
            This is a contradicts to our assumption that such an \( x \) exists.\\
            Thus, for any \( b \in \mathbb{Z}_m \) that is not divisible by \( d \), the equation 
            \( ax \equiv b \text{ (mod }m) \) has no solution. \\
            Therefore, there exists a \( b \in \mathbb{Z}_m \) such 
            that the modular equation \( ax \equiv b \text{ (mod }m) \) has no solution when \( a \in \mathbb{Z}_m \setminus \mathbb{Z}^*_m \).
         \end{answer}
     \end{part}
\newpage
     \begin{part}
        \begin{answer}
            Assume \( h \) is a generator of $\mathbb{G}$ where \( h = g^a \), and \( a \in \mathbb{Z}_m \).\\
            By the definition of a generator, we know that the set \( \{h^x : x \in \{0, 1, \ldots, |\mathbb{G}| - 1\}\} = \mathbb{G} \).\\
            Since \( g \) is a generator of $\mathbb{G}$, for some \( b \in \mathbb{Z}_m \) and \( x \in \{0, 1, \ldots, |G| - 1\} \), we have 
            \[ h^x \equiv g^{ax} \equiv g^b \text{ (mod }m). \]
            For \( h \) to be a generator, the equation \( ax \equiv b \text{ (mod }m) \) must have a solution for every \( b \in \mathbb{Z}_m \).\\
            From part (a) and part (b), we know that the equation \( ax \equiv b \text{ (mod }m) \) has a solution for all \( b \in \mathbb{Z}_m \) 
            iff \( a \in \mathbb{Z}^*_m \) (since \( a \) and \( m \) must be coprime).\\
            Thus, \( h = g^a \) is a generator of $\mathbb{G}$ iff \( a \) is an element of \( \mathbb{Z}^*_m \).\\
            Since the number of elements in \( \mathbb{Z}^*_m \) is \( \phi(m) \) (by Euler's totient function), we know that 
            there are exactly \( \phi(m) \) such \( a \)'s in \( \mathbb{Z}_m \) for which \( h = g^a \) is a generator. \\
            Therefore, there are exactly \( \phi(m) \) generators in $\mathbb{G}$.
        \end{answer}
     \end{part}

     \begin{part}
        \begin{answer}
            \textbf{When \( m \) is prime, every element of \(\mathbb{G}\) (other than the identity $1$) is a generator of the group.}\\
            Since \( m \) is prime, \( \phi(m) = m - 1 \). \\
            In a cyclic group \( \mathbb{G} \), every element can be represented as \( g^a \) for some integer \( a \) where \( 0 \leq a < m \),
            and \( g^0 \) is the identity element.\\
            For every \( a \) in  \( 1 \leq a < m \), \( a \) is coprime with \( m \) since \( m \) is prime.\\
            From part (c), we know that an element \( h = g^a \) is a generator of \( \mathbb{G} \) if and only if \( a \) is coprime with 
            \( m \). \\
            Since every \( a \) in the range \( 1 \leq a < m \) satisfies this condition, every such \( h = g^a \) is a generator.\\
            Therefore, all \( m-1 \) elements of \( G \) other than the identity element are generators.

        \end{answer}
     \end{part}

\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 2 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 2 - Group Order Factorization \& Discrete Logarithms (15 points)}
    \begin{part}
       \begin{answer}
            Since the elements in \( \langle g^\alpha \rangle \) are \( \{g^\alpha, g^{2\alpha}, g^{3\alpha}, \ldots\} \), to know the order of
            $\langle g^\alpha \rangle$, we need to find the smallest positive integer \( i \) such that \( (g^\alpha)^i = 1 \).\\
            Since \( g \) is a generator of $\mathbb{G}$, we have \( g^m = 1 \), where \( 1 \) is the identity element in $\mathbb{G}$.\\
            Given \( m = \alpha \cdot n \), we know that \( g^{\alpha n} = g^m = 1 \).\\
            Since for any $i' < n$, $\alpha \cdot i' < \alpha \cdot n = m$, we know that $g^{i' \alpha} \neq 1$.\\
            Since \( g^{\alpha n} = 1 \) and $g^{i' \alpha} \neq 1$ for all $i' < n$, the smallest \( i \) for which \( (g^\alpha)^i = 1 \) is \( n \).\\
            Therefore, the order of \( \langle g^\alpha \rangle \) is \( n \).
        \end{answer}
    \end{part}

    \begin{part}
        \begin{answer}
            Since \( X = g^x \), we have \( X^\alpha = (g^x)^\alpha = g^{x\alpha} \).\\
            Since the discrete logarithm of \( X \) to the base \( g^\alpha \) is the smallest non-negative integer
            \( i \) such that \( (g^\alpha)^i = X\), our goal is to find \( i \) such that \( (g^\alpha)^i = X = g^{x\alpha} \).\\
            Since \( (g^\alpha)^i = g^{\alpha i} = g^{x\alpha} \) and $|\mathbb{G}| = m$, we know that \( \alpha i \equiv x\alpha \text{ (mod } m) \).\\
            From part (a) we know that the group $\langle g^\alpha \rangle$ has order $n$, and since $m = \alpha \cdot n$, we can 
            simplify  \( \alpha i \equiv x\alpha \text{ (mod } m) \) to \( i \equiv x \text{ (mod } n) \) \\
            Since \( i \) is a discrete logarithm, it has to be between \( 0 \) and \( n - 1 \).\\
            Therefore, the discrete logarithm of \( X^\alpha \) to the base \( g^\alpha \) is the smallest non-negative integer \( i \) 
            such that \( i \equiv x \text{ (mod } n) \), where \( 0 \le i \le n -1\) (i.e. $i$ is the remainder of $x$ divided by $n$).
        \end{answer}
    \end{part}
\newpage
    \begin{part}
        \begin{answer}
            Let $\mathbb{G}$ be the group $\mathbb{Z}_p^*$, and $g$ be a generator of $\mathbb{G}$.\\
            Since $p$ is prime, we know that $\mathbb{Z}_p^*$ has order $p - 1$.\\
            We first need to construct a function that takes $X = g^x$ and compute the discrete logarithm $x$ in group $\mathbb{G}$ using Baby-Step Giant-Step:
            \begin{center}
                \begin{tabular}{|l|}
                    \hline
                        \underline{\textbf{function} BSGS($X$):} \\
                            $m \leftarrow |\mathbb{G}|$\\
                            $k \leftarrow \lceil \sqrt{m} \;\rceil$ \\
                            \textbf{For} $q = 0$ \textbf{to} $k - 1$ \textbf{do}\\ 
                            \hspace*{22pt} $G[q] \leftarrow g^{q \cdot k}$\\
                            \textbf{For} $r = 0$ \textbf{to} $k - 1$ \textbf{do}\\
                            \hspace*{22pt} \textbf{If} $\exists q: G[q] = X \cdot g ^{-r}$ \textbf{then return} $x = q \cdot k + r$\\
                        \hline
                \end{tabular}
            \end{center}
            
            We can then construct a distinguisher that calls the function BSGS():
            \begin{center}
                \begin{tabular}{|l|}
                    \hline
                        \underline{\textbf{distinguisher} $D^{\text{DDH}_{b [\mathbb{G}, g]}}$:} \\
                            $(X,Y,Z) \leftarrow \text{DHH}_{b[\mathbb{G}, g]}$\\
                            $x \leftarrow \text{BSGS}(X)$\\
                            $y \leftarrow \text{BSGS}(Y)$\\
                            \textbf{If} $Z \ne g^{xy}$ \textbf{then return} $1$\\
                            \textbf{else return} $0$\\
                        \hline
                \end{tabular}
            \end{center}
            Note that $\Pr[D^{\text{DDH}_{0[\mathbb{G},g]}} \Rightarrow 1] = 0$, because the BSGS function, in this case, will return $x$ and $y$ such that $Z = g^{xy}$.\\
            Also, $\Pr[D^{\text{DDH}_{1[\mathbb{G},g]}} \Rightarrow 1] = 1 - \frac{1}{|\mathbb{G}|} = 1 - \frac{1}{p - 1}$, because in this case, $Z = g^{xy}$ only when
            the discrete log $z$ of $Z = g^z$ collides with the product of $x$ and $y$ which has probability $\frac{1}{|\mathbb{G}|} = \frac{1}{p - 1}$.\\
            Therefore, we have $$\text{Adv}^{\text{ddh}}_{\mathbb{G}, g} = |\Pr[D^{\text{DDH}_{0[\mathbb{G},g]}} \Rightarrow 1] -  \Pr[D^{\text{DDH}_{1[\mathbb{G},g]}} \Rightarrow 1]|
            = |0 - (1 - \frac{1}{p})| = 1 - \frac{1}{p}$$ which is non-negligible.\\
            Since the Baby-Step-Giant step function runs in time polynomial in $\log(p)$, the distinguisher $D$ also runs in time polynomial in $\log(p)$.\\
            Therefore, the DDH assumption cannot be true in $\mathbb{Z}^*_p$ for a prime $p$.
        \end{answer}
    \end{part}
\newpage
    \begin{part}
        \begin{answer}
            - For each prime \( p_i \), calculate the discrete logarithm \( x_i \) of \( X \equiv g^{x_i} \text{ (mod } p_i )\) using Baby-Step Giant-Step similar to part(c) (note $i = 1, ... , 44$):
            \begin{center}
                \begin{tabular}{|l|}
                    \hline
                        \underline{\textbf{function} BSGS($X$):} \\
                            $x \leftarrow \text{empty array}$\\
                            \textbf{For} i = 1 to 44 \textbf{do}\\
                            \hspace*{22pt}$m \leftarrow |\mathbb{Z}^*_{p_i}|$\\
                            \hspace*{22pt}$k \leftarrow \lceil \sqrt{m} \;\rceil$ \\
                            \hspace*{22pt}\textbf{For} $q = 0$ \textbf{to} $k - 1$ \textbf{do}\\ 
                            \hspace*{22pt}\hspace*{22pt} $G[q] \leftarrow g^{q \cdot k}$\\
                            \hspace*{22pt}\textbf{For} $r = 0$ \textbf{to} $k - 1$ \textbf{do}\\
                            \hspace*{22pt}\hspace*{22pt} \textbf{If} $\exists q: G[q] = X \cdot g ^{-r}$ \textbf{then} $x[i] = q \cdot k + r$\\
                        \textbf{return} $x$\\
                        \hline
                \end{tabular}
            \end{center}
            Since the complexity of each discrete logarithm calculation is \( O(\sqrt{p_i} \log(p_i)) \), we need roughly 
            $44 \times \sqrt{193} \times \log(193) \approx 44 \times 31.8 \approx 1408$ group exponentiations to calculate all 44 discrete logarithms.\\

            - Since the Chinese Remainder Theorem states that if we have a set of congruences \( x \equiv x_i \text{ (mod } p_i)  \) for \( i = 1, \ldots, 44 \), then there is a unique \( x \text{ (mod } m) \) 
            that satisfies all these congruences. \\
            Once we have \( x_i \) for each \( p_i \), we can use CTR to reconstruct \( x \text{ (mod } m) \), and the reconstruction of \( x \text{ (mod } m)\) from \( x_1 \text{ (mod } p_1), \ldots, x_{44} \text{ (mod } p_{44}) \) 
            should be efficient.\\

            - Once we finished reconstructing \( x \text{ (mod } m) \), we can return \( x \) as the discrete logarithm $x$ of \( X = g^x \) in the group \( \mathbb{G}\).\\
            Since total number of group exponentiations is mostly discrete logarithm calculations and we are only performing these calculations for 44 different primes, 
            the total number of operations, as shown above, should be in the order of a few thousand.\\

        \end{answer}
    \end{part}

\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 3 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 3 - A Liitle Number Theory (5 points)} 
    \begin{part}
       \begin{answer}
            By the definition of the Euler's totient function, since $P$ and $Q$ are prime and $N = PQ$, we know that 
            $$\phi(N)= \phi(PQ) = (P - 1)(Q - 1)$$
            We can simply it further:
            \begin{align*}
                \phi(N) &= (P - 1)(Q - 1) \\
                \phi(N) &= PQ - P - Q + 1 \\
                \phi(N) &= N - P - \frac{N}{P} + 1 \tag*{Since $N = PQ$, $Q = \frac{N}{P}$}\\
                \phi(N) \cdot P &= N \cdot P - P^2 - N + P \tag*{Multiply both sides by $P$}\\
                0 &= -P^2 + N \cdot P - \phi(N) \cdot P + P - N \tag*{Move all terms to the left side}\\ 
                0 &= -P^2 + (N - \phi(N) + 1) \cdot P - N \tag*{Factor out $P$}\\
            \end{align*}
            We can then use the quadratic formula to solve for $P$:
            $$ P = \frac{-(N - \phi(N) + 1) \pm \sqrt{(N - \phi(N) + 1)^2 - 4 \cdot (-1) \cdot (-N)}}{2 \cdot (-1)}$$
            Once we have $P$, we can find $Q$ by plugging $P$ into $Q = \frac{N}{P}$.
            Since all the calculation described above including the square root operation can be implemented in polynomial time of the 
            bitlength of $N$ ($\log N$), we know the algorithm can efficiently find $P$ and $Q$ given $N$ and $\phi(N)$ (from the black box 
            algorithm) in time polynomial in $\log N$. \\
            Therefore, we have shown we can efficiently factor $N$ given $N$ and the black box algorithm that computes $\phi(N)$.
       \end{answer}
    \end{part}

\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 4 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 4 - Collision-Resistance from Discrete Logarithms (8 points)} 
    \begin{part}
       \begin{answer}
            By the definition of the hash function, we know that $\text{H}(S, (x_1, x_2)) = g^{x_1}S^{x_2}$, and 
            $\text{H}(S, (x'_1, x'_2)) = g^{x'_1}S^{x'_2}$. \\
            Given a collision $H(S, (x_1, x_2)) = H(S, (x'_1, x'_2))$, we know that $g^{x_1}S^{x_2} = g^{x'_1}S^{x'_2}$.\\
            Since $S = g^x$ for some unknown $x$, we can rewrite the equation in terms of $x$:
            \begin{align*}
                g^{x_1}S^{x_2} &= g^{x'_1}S^{x'_2} \\
                g^{x_1}(g^{x})^{x_2} &= g^{x'_1}(g^{x})^{x'_2} \tag*{Since $S = g^x$}\\
                g^{x_1 + x \cdot x_2} &= g^{x'_1 + x \cdot x'_2} 
            \end{align*}
            Now, we can use the fact that $\mathbb{G}$ is of prime order $p$. In a group of prime order $p$ with generator $g$, 
            we know that $g^p = 1$ (the identity element). Also, since the group is cyclic, we can reduce the exponents by modulo 
            $p$ without altering the group element it represents. Therefore, we can reduce the equation to:
            \begin{align*}
                x_1 + x \cdot x_2 &\equiv x'_1 + x \cdot x'_2 \text{ (mod } p) \\
                x_1 - x'_1 &\equiv x \cdot (x'_2 - x_2) \text{ (mod } p) \\
                x &\equiv (x_1 - x'_1)(x'_2 - x_2)^{-1} \text{ (mod } p) \tag*{Since $x'_2 - x_2$ is coprime with $p$}
            \end{align*}
        Therefore, we have shown that given a collision $H(S, (x_1, x_2)) = H(S, (x'_1, x'_2))$, we can efficiently compute $x$ 
        such that $S = g^x$ simply by calculating $(x_1 - x'_1)(x'_2 - x_2)^{-1} \text{ (mod } p)$.\\
       \end{answer}
    \end{part}
\newpage
    \begin{part}
        \begin{answer}
            To find a collision for the hash function $H$ for a chosen $S = g^x$,
            our goal is to show that it's possible to find two different inputs \((x_1, x_2) \neq (x'_1, x'_2)\) 
            such that \( H(S, (x_1, x_2)) = H(S, (x'_1, x'_2)) \). (i.e. show the reverse of part (a) is true.)\\
        
            Since the hash function \( H : G \times \mathbb{Z}_p^2 \rightarrow G \) is defined as 
            \( H(S, (x_1, x_2)) = g^{x_1} S^{x_2} \). If the malicious entity sets \( S = g^x \), the hash function 
            becomes \( H(g^x, (x_1, x_2)) = g^{x_1} (g^x)^{x_2} = g^{x_1 + xx_2} \).

            The entity knows \( x \) and can manipulate \( x_1 \) and \( x_2 \) to create a collision. 
            For example, they can choose two different pairs \((x_1, x_2)\) and \((x'_1, x'_2)\) such that:

            \[ g^{x_1 + xx_2} = g^{x'_1 + xx'_2} \]

            Using the result from the part(a), we know that if a collision exists:

            \[ x_1 + xx_2 \equiv x'_1 + xx'_2 \text{ (mod } p) \]

            Since the adversary knows \( x \), they can easily find pairs \((x_1, x_2)\) and \((x'_1, x'_2)\) that satisfy 
            this equation. One option could be to choose \( x_2 \) and \( x'_2 \) arbitrarily and then compute 
            \( x_1 \) and \( x'_1 \):

            \[ x_1 = x'_1 + xx'_2 - xx_2 \text{ (mod } p) \]

            Since the malicious entity controls \( x \) and can freely choose \( x_2 \) and \( x'_2 \), they can 
            manipulate the equation to find a collision.\\ 
            Therefore, we have shown that if the seed \( S \) is chosen maliciously 
            as \( g^x \) for a known \( x \), the hash function \( H \) effectively has a backdoor to create collisions.\\
        \end{answer}
    \end{part}

\end{question}

%%%%%%%%%%%%%%%%%%%%%%%% Task 5 %%%%%%%%%%%%%%%%%%%%%%%%
\begin{question}{Task 5 - Security of Key-Agreement Protocols (9 points)} 
    \begin{part}
       \begin{answer}
            From the key-generation protocol, we know the following:
            \begin{align*}
                s &= k \oplus r \\
                u &= s \oplus t \\
                w &= u \oplus r 
            \end{align*}
            To show that Alice and Bob output the same key, we need to show that $k = w \oplus t$.\\
            We can start by substituting $w$ with $u \oplus r$:
            \begin{align*}
                w \oplus t &= u \oplus r\oplus t \tag*{Substitute $w$ with $u \oplus r$}\\
                &= s \oplus t \oplus r \oplus t \tag*{Substitute $u$ with $s \oplus t$}\\
                &= k \oplus r \oplus t \oplus r \oplus t \tag*{Substitute $s$ with $k \oplus r$}\\
                &= k \oplus r \oplus r \oplus t \oplus t \tag*{Rearrange terms}\\
                &= k \tag*{Since $r \oplus r = 0$ and $t \oplus t = 0$}
            \end{align*}
            Therefore, we have shown that $k = w \oplus t$, and Alice and Bob output the same key.
       \end{answer}
    \end{part}
\newpage
    \begin{part}
        \begin{answer}
            Assume we have the following oracles defined on the key-agreement protocol described in the question:
            \begin{center}
            \begin{tabular}{|l|}
                \hline
                    \underline{\textbf{oracle} $\text{LR}_0$[KA]:} \\\\
                    \underline{private \textbf{procedure} Init():}\\
                        $K,r,t \overset{\text{\$}}{\leftarrow} \{0,1\}^n$\\
                        $S \leftarrow K \oplus r$\\
                        $U \leftarrow S \oplus t$\\
                        $W \leftarrow U \oplus r$\\
                        \textbf{return} $(S,U,W,K)$\\
                    \hline
            \end{tabular}
            \begin{tabular}{|l|}
                \hline
                    \underline{\textbf{oracle} $\text{LR}_1$[KA]:} \\\\
                    \underline{private \textbf{procedure} Init():}\\
                        $K,r,t \overset{\text{\$}}{\leftarrow} \{0,1\}^n$\\
                        $S \leftarrow K \oplus r$\\
                        $U \leftarrow S \oplus t$\\
                        $W \leftarrow U \oplus r$\\
                        $K' \overset{\text{\$}}{\leftarrow} \{0,1\}^n$\\
                        \textbf{return} $(S,U,W,K')$\\
                    \hline
            \end{tabular}               
        \end{center}
            With the above oracle we can construct the following distinguisher:\\
            \begin{center}
                \begin{tabular}{|l|}
                    \hline
                        \underline{\textbf{distinguisher} $D^{\text{LR}_{b [\text{KA}]}}$:} \\
                            $(S,U,W,K) \leftarrow \text{LR}_{b[\text{KA}]}$\\
                            \textbf{If} $S \oplus U \oplus W \oplus K = 0$ \textbf{then return} $1$\\
                            \textbf{else return} $0$\\
                        \hline
                \end{tabular}
            \end{center}
            Note that $\Pr[D^{\text{LR}_{0[\text{KA}]}} \Rightarrow 1] = 1$, because by the definition, we know the following:
            \begin{align*}
                S \oplus U \oplus W \oplus K &= (K \oplus r) \oplus (K \oplus r \oplus t) \oplus (K \oplus r \oplus t \oplus r) \oplus K \\
                &= K \oplus r \oplus K \oplus r \oplus t \oplus K \oplus r \oplus t \oplus r \oplus K \\
                &= K \oplus K \oplus K \oplus K \oplus r \oplus r \oplus r \oplus r \oplus t \oplus t \\
                &= 0
            \end{align*}
            So the distinguisher will always return $1$.\\
            However, $\Pr[D^{\text{LR}_{1[\text{KA}]}} \Rightarrow 1] = \frac{1}{2^n}$, because we know the following:
            \begin{align*}
                S \oplus U \oplus W \oplus K' &= (K \oplus r) \oplus (K \oplus r \oplus t) \oplus (K \oplus r \oplus t \oplus r) \oplus K' \\
                &= K \oplus K \oplus K \oplus K' \oplus r \oplus r \oplus r \oplus r \oplus t \oplus t \\
                &= K \oplus K' 
            \end{align*}
            Since $K$ and $K'$ are chosen uniformly at random, the probability that $K \oplus K' = 0$ is $\frac{1}{2^n}$.\\
            Therefore we have $$\text{Adv}^{\text{LR}}_{\text{KA}} = |\Pr[D^{\text{LR}_{0[\text{KA}]}} \Rightarrow 1] -  \Pr[D^{\text{LR}_{1[\text{KA}]}} \Rightarrow 1]|
            = |1 - \frac{1}{2^n}| = 1 - \frac{1}{2^n}$$ which is not negligible.\\
            Therefore, we have shown that the key-agreement protocol is not secure because $(S,U,W,K)$ and $(S,U,W,K')$ are easily distinguishable.
        \end{answer}
    \end{part}

\end{question}

\end{document}